<?php if (!defined('BASEPATH')) exit('No direct script access allowed');

class Validate {
	
	public function __construct() {
		$this->load->library('form_validation');
		$this->load->library('input');
	}
	
	public function post($rules) {
		/* set all the rules sent in */
		$this->form_validation->set_rules($rules);
	
		/* prep our return value */
		$rtn = array();

		/* run the validation */
		$rtn['err'] = !$this->form_validation->run();

		/* capture a raw responds */
		$rtn['errors'] = validation_errors();

		/* capture a array responds */
		$rtn['errors_array'] = $this->form_validation->error_array();

		/* return the error or array of errors */
		return $rtn;
	}

	/*
	filter a value (passed by reference) using a form validation string
	optionally dying or returning true (pass) false (fail)
	*/

	public function filter(&$value,$filter,$return=true)
	{
		$bogus = 'foobarvariable';
		
		/* make sure it's reset - incase it's already loaded and used we need it empty */
		$this->form_validation->reset_validation();

		/* setup a bogus array for testing - set_data before set_rule!! */
		$this->form_validation->set_data(array($bogus=>$value));

		/* setup our rule on the bogus array key for testing using the filter sent in - bogus name "input filter" */
		$this->form_validation->set_rules($bogus, 'input filter', $filter);

		/* run the validation and capture output */
		$pass = $this->form_validation->run(); /* true = pass */

		/* recapture the processed variable */
		$value = $this->form_validation->set_value($bogus);

		/* log the error if any */
		if ($pass === false ) {
			log_message('info','Validate::filter '.$value.'/'.validation_errors().'/'.$filter);
		}

		/*
		if the validation failed AND they want to "die hard" - do it 
		This is might be needed when you already validated the input or had 
		values generated by code they for you know the input should be good
		except somebody is now manually trying to send in "different" values
		*/
		if ($return == false && $pass == false) {
			show_error('FAIL: Incorrect Input',404);
			die();
		}

		/* return the pass boolean */
		return $pass;
	}

	/*
	capture form elements using a validation array adding
	dbfield (defaults to field)
	default [optional]

	returns pass (true) / fail (false)
	*/

	public function map($rules,&$output,&$input=null,$xss = true,$return=true)
	{		
		/* did they send in input? if not use post with xss by default */
		$input = ($input) ? $input : $this->input->post(NULL, $xss); /* XSS cleaned */

		/* loop through all the form validation rules with the additional map rules! */
		foreach ($rules as $r) {
			/* form field */
			$field = $r['field'];

			/* if database field not filled in use form field */
			$dbfield = ($r['dbfield']) ? $r['dbfield'] : $field;

			/* insert the default if the input field is invalid (good for checkboxes!) */
			$value = $prevalue = (isset($input[$dbfield])) ? $input[$dbfield] : $r['default'];

			/* run the filter on this value using return if sent in */
			if ($this->filter($value,$r['rules'],$return) === false) {
				/* if it fails then return immediately */
				log_message('info','Validate::map '.$prevalue.'/'.$value.'/'.validation_errors().'/'.$r['rules']);
				return false; /* fail */
			}

			/* if not then build the output array (passed by ref) with the new value (prepping for example) */
			$output[$dbfield] = $value;
		}
		
		/* return true because all validations passed */
		return true;
	}
	
	public function remove(&$v,$name) {
		foreach ($v as $key => $record) {
			if ($v[$key]['field'] == $name) {
				unset($v[$key]);
				break;
			}
		}
		
		return $this;
	}
	
	/* wrapper for CI instance */
	public function __get($var)
	{
		return get_instance()->$var;
	}	
	
	
} /* end validation */